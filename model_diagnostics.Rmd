---
title: "model_diagnostics"
author: "Yida Wang"
date: "12/12/2021"
output: github_document
---

```{r}
library(tidyverse)
library(modelr)
library(patchwork)
library(MASS)
library(ggplot2)
library(leaps)
library(performance)

```

## import data
```{r}
cdi = read.csv("./data/cdi.csv")

cdi = 
  cdi %>% 
  mutate(
    # crm_1000 is already generated in Xiao's part
    crm_1000 = crimes/pop * 1000,
    poparea = pop/area,
    docs = docs/pop * 1000,
    beds = beds/pop * 1000,
    # mutatation for the region needs to stay here (not in Xiao's part)
    region = as.factor(region)
  ) %>% 
  dplyr::select(-id,-cty,-state,-crimes)
```
### Model 1: Full model
Let's first fit the model with all the predictors:
```{r}
model1 = lm(crm_1000 ~ ., data = cdi)

broom::tidy(model1) %>% 
  knitr::kable()
```

We can see that the variables `area`, `pop65`, `docs`, `bagrad`, `unemp` are all not very significant with a p-value larger than 0.05.


### Model 2: Model found by looking at correlation clusters
Then, plot a heatmap for the correlations among all the variables.

```{r}
res = cor(cdi %>% dplyr::select(-region))
round(res, 2) %>%
  knitr::kable()


col <- colorRampPalette(c("blue", "white", "red"))(20)
heatmap(x = res, col = col, symm = TRUE)
```

According to the clusters generated by R, we then choose variables that are not highly related with each other and are highly related to the outcome `crm_1000`.

```{r}
model2 = lm(crm_1000 ~ pop18 + pcincome + hsgrad + pop65 + poverty + beds + poparea + region, data = cdi)

broom::tidy(model2) %>% 
  knitr::kable()
```


### Model 3: Step-wise model based on model 2

Conduct the automatic step-wise process on the predictors used in model 2.
```{r}
mult.fit = lm(crm_1000 ~ pop18 + pcincome + hsgrad + pop65 + poverty + beds + poparea + region, data = cdi)
step(mult.fit, direction = "both")

# Obtain a new model 3
model3 = lm(crm_1000 ~ pop18 + pcincome + poverty + beds + poparea + region, data = cdi)

broom::tidy(model3) %>% 
  knitr::kable()
```

Model 3 is rather good, and with a smaller number of predictors.

Then we need to see the residual plot for model 3 in order to get some insight of some potential transformation.
```{r}
cdi %>% 
  add_predictions(model3) %>% 
  add_residuals(model3) %>% 
  ggplot(aes(x = pred, y = resid)) +
  geom_point(alpha = 0.4) + 
  geom_smooth(se = F, color = "red", method = "lm") +
  labs(title = "Risidual Plot for model 3",
       x = "Fitted Value", 
       y = "Residual")
```

The residuals are randomly scattered so we may suppose that linearity has already been achieved.


### Model 4: Try to add interaction terms in model 3

We can then consider adding some potential interaction terms to model 3. So what interaction terms can we add?

We suppose the terms that both have significant main effect on the outcomes may interact together on the outcomes, so we add the pairwise interactions of `poparea`, `poverty`, `region` and `beds` into model 3. Next, Apply step-wise process on it to come up with a new model.
```{r}
mult.fit = lm(crm_1000 ~ pop18 + pcincome + poverty + beds + poparea + region + poparea*poverty + poparea*region + poverty*region + beds*poparea + beds*region + beds*poverty, data = cdi)
step(mult.fit, direction = "both")

model4 = lm(crm_1000 ~ pop18 + pcincome + poverty + beds + poparea + region + poparea*region + poparea*poverty + poparea*beds, data = cdi)

broom::tidy(model4) %>% 
  knitr::kable()
```


### Model 5 & 6: Model based on internet searching result
In addition, we can try to find other models based on the searching results of the potentially related factors of crime rates: age, medical resources, educational level, poverty, unemployment rate, personal income and population density per square mile.

```{r}
model5 = lm(crm_1000 ~ pop18 + beds + hsgrad + poverty + unemp + pcincome + poparea, data = cdi)

broom::tidy(model5) %>% 
  knitr::kable()
```

Then we use step-wise process based on the predictors used in model 4.

```{r}
mult.fit = lm(crm_1000 ~ pop18 + beds + hsgrad + poverty + unemp + pcincome + poparea, data = cdi)
step(mult.fit, direction = "both")

model6 = lm(crm_1000 ~ pop18 + beds + poverty + unemp + pcincome + poparea, data = cdi)

broom::tidy(model6) %>% 
  knitr::kable()
```

Draw the residual plots:
```{r}
res5 = 
  cdi %>% 
  add_predictions(model5) %>% 
  add_residuals(model5) %>% 
  ggplot(aes(x = pred, y = resid)) +
  geom_point(alpha = 0.4) + 
  geom_smooth(se = F, color = "red", method = "lm") +
  labs(title = "Risidual Plot for model 5",
       x = "Fitted Value", 
       y = "Residual")

res6 = 
  cdi %>% 
  add_predictions(model6) %>% 
  add_residuals(model6) %>% 
  ggplot(aes(x = pred, y = resid)) +
  geom_point(alpha = 0.4) + 
  geom_smooth(se = F, color = "red", method = "lm") +
  labs(title = "Risidual Plot for model 6",
       x = "Fitted Value", 
       y = "Residual")

res5 + res6
```

By the residual plot for the above two models, we cannot see a big difference.



### Model 7: Step-wise model generated with all the variables

```{r}
# Use step-wise regression to try to find a mlr model
mult.fit = lm(crm_1000 ~ ., data = cdi)
step(mult.fit, direction = "both")
```

According the above results of step-wise regression in R, the predicting model of `crm_1000` contains the continuous predictors `pop`, `pop18`, `beds`, `hsgrad`, `bagrad`, `poverty`, `pcincome`, `totalinc`, `poparea` and the categorical predictor `region`.

Then we fit the multiple linear regression model 6 for crime rates:
```{r}
model7 = lm(crm_1000 ~ pop + pop18 + beds + hsgrad + bagrad + poverty + pcincome + totalinc + poparea + region, data = cdi)

broom::tidy(model7) %>% 
  knitr::kable()
```


So we try to compare the models by ploting their RMSE values.
```{r}
# I've only chose model 3, 4, 7 here to compare their RMSE values
cv = crossv_mc(cdi, 100) %>% 
    mutate(
    train = map(train, as_tibble),
    test = map(test, as_tibble)
  ) %>% 
  mutate(
    model_3 = map(train, ~lm(crm_1000 ~ pop18 + pcincome + poverty + beds + poparea + region, data = cdi)),
    model_4 = map(train, ~lm(crm_1000 ~ pop18 + pcincome + poverty + beds + poparea + region + poparea*region + poparea*poverty + poparea*beds, data = cdi)),
    model_7 = map(train, ~lm(crm_1000 ~ pop + pop18 + beds + hsgrad + bagrad + poverty + pcincome + totalinc + poparea + region, data = cdi))) %>% 
  mutate(
    rmse_model3 = map2_dbl(model_3, test, ~rmse(model = .x)),
    rmse_model4 = map2_dbl(model_4, test, ~rmse(model = .x)),
    rmse_model7 = map2_dbl(model_7, test, ~rmse(model = .x))
    )

cv %>% 
  dplyr::select(starts_with("rmse")) %>% 
  pivot_longer(
    everything(),
    names_to = "model",
    values_to = "rmse",
    names_prefix = "rmse_" 
  ) %>% 
  ggplot(aes(x = model, y = rmse)) +  geom_violin(fill = "orange",alpha = 0.4) +
  geom_boxplot(alpha = 0.5, color = "red") 

```

## diagnostics
residual vs fitted plot


```{r}
par(mfrow = c(2,3))

plot(model2, which = 1)
plot(model3, which = 1)
plot(model4, which = 1)
plot(model5, which = 1)
plot(model6, which = 1)
plot(model7, which = 1)
```

QQ plot
```{r}
par(mfrow = c(2,3))

plot(model2, which = 2)
plot(model3, which = 2)
plot(model4, which = 2)
plot(model5, which = 2)
plot(model6, which = 2)
plot(model7, which = 2)
```

Scale-Location
```{r}
par(mfrow = c(2,3))

plot(model2, which = 3)
plot(model3, which = 3)
plot(model4, which = 3)
plot(model5, which = 3)
plot(model6, which = 3)
plot(model7, which = 3)
```

Residual
```{r}
par(mfrow = c(2,3))

plot(model2, which = 5)
plot(model3, which = 5)
plot(model4, which = 5)
plot(model5, which = 5)
plot(model6, which = 5)
plot(model7, which = 5)
```

## Box-Cox transformation

```{r}
boxcox(model2, lambda = seq(-3, 3, by = 0.25))
boxcox(model3, lambda = seq(-3, 3, by = 0.25))
boxcox(model4, lambda = seq(-3, 3, by = 0.25))
boxcox(model5, lambda = seq(-3, 3, by = 0.25))
boxcox(model6, lambda = seq(-3, 3, by = 0.25))
boxcox(model7, lambda = seq(-3, 3, by = 0.25))
```



## outliers

6 and 215 are most obvious two
```{r}
sum_cdi = cdi
summary(sum_cdi)
```

```{r}

sum_cdi_df = sum_cdi[-c(6,215),]
```
for model 2
```{r}
old2 = lm(crm_1000 ~ pop18 + pcincome + hsgrad + pop65 + poverty + beds + poparea + region, data = cdi)
new2 = lm(crm_1000 ~ pop18 + pcincome + hsgrad + pop65 + poverty + beds + poparea + region, data = sum_cdi_df)
summary(old2); summary(new2)

```
for model 3
```{r}
old3 = lm(crm_1000 ~ pop18 + pcincome + poverty + beds + poparea + region, data = cdi)
new3 = lm(crm_1000 ~ pop18 + pcincome + poverty + beds + poparea + region, data = sum_cdi_df)
summary(old3); summary(new3)

```
for model 4
```{r}
old4 = lm(crm_1000 ~ pop18 + pcincome + poverty + beds + poparea + region + poparea*region + poparea*poverty + poparea*beds, data = cdi)
new4 = lm(crm_1000 ~ pop18 + pcincome + poverty + beds + poparea + region + poparea*region + poparea*poverty + poparea*beds, data = sum_cdi_df)
summary(old4); summary(new4)

```
for model 5
```{r}
old5 = lm(crm_1000 ~ pop18 + beds + hsgrad + poverty + unemp + pcincome + poparea, data = cdi)
new5 = lm(crm_1000 ~ pop18 + beds + hsgrad + poverty + unemp + pcincome + poparea, data = sum_cdi_df)
summary(old5); summary(new5)

```
for model 6
```{r}
old6 = lm(crm_1000 ~ pop18 + beds + poverty + unemp + pcincome + poparea, data = cdi)
new6 = lm(crm_1000 ~ pop18 + beds + poverty + unemp + pcincome + poparea, data = sum_cdi_df)
summary(old6); summary(new6)

```
for model 7
```{r}
old7 = lm(crm_1000 ~ pop + pop18 + beds + hsgrad + bagrad + poverty + pcincome + totalinc + poparea + region, data = cdi)
new7 = lm(crm_1000 ~ pop + pop18 + beds + hsgrad + bagrad + poverty + pcincome + totalinc + poparea + region, data = sum_cdi_df)
summary(old7); summary(new7)

```


## colinearility

```{r}
cdi %>% 
  dplyr::select(-crm_1000) %>% 
  mutate(
    region = factor(region)) %>%
  GGally::ggcorr(label = TRUE, label_size = 2, hjust = 0.8)
```
pop and totalinc(1)
pcincome and bagrad(0.7)
hsgrad and bagrad(0.7)
beds and docs(0.7)

```{r}
check_collinearity(model2)
check_collinearity(model3)
check_collinearity(model4)
check_collinearity(model5)
check_collinearity(model6)
check_collinearity(model7)
```